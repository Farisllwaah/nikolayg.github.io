---
layout: post
title: Monads in 15 minutes
date: 2013-12-10 11:28:29.000000000 +11:00
type: post
published: true
status: publish
categories:
- Miscellaneous
tags:
- Functional programming
- Monad
- Python
meta:
  _wpas_done_all: '1'
  _wpcom_is_markdown: '1'
  _publicize_pending: '1'
  publicize_google_plus_url: https://plus.google.com/116873873608085229608/posts/Am1XhHDCUKu
  _wpas_done_5385652: '1'
  _publicize_done_external: a:1:{s:11:"google_plus";a:1:{s:21:"116873873608085229608";b:1;}}
  publicize_twitter_user: nikolaygrozev
  publicize_twitter_url: http://t.co/cgZe743SXF
  _wpas_done_5385644: '1'
  publicize_linkedin_url: http://www.linkedin.com/updates?discuss=&scope=30071619&stype=M&topic=5815970047944192000&type=U&a=AxFv
  _wpas_done_5385639: '1'
  _wpas_skip_5385652: '1'
  _wpas_skip_5385644: '1'
  _wpas_skip_5385639: '1'
  geo_public: '0'
  _edit_last: '1'
  _kad_blog_head: default
  _kad_post_summery: default
  _kad_post_sidebar: 'yes'
  _kad_sidebar_choice: sidebar-primary
  _kad_blog_author: default
  _kad_blog_carousel_similar: default
  _thumbnail_id: '70'
author:
  login: nikolaygrozev
  email: nikolay.grozev@gmail.com
  display_name: nikolaygrozev
  first_name: ''
  last_name: ''
---
<h1>Introduction</h1>
<p>At the <a href="http://yowconference.com.au/">YOW! 2013</a> conference one of the designers of Haskell <a href="http://homepages.inf.ed.ac.uk/wadler/">prof. Philip Wadler</a> illustrated how Monads enable a purely functional programming language to perform inherently imperative operations like I/O and exception handling. Not surprisingly, there has been a lot of interest in the topic resulting in almost exponential growth of Monads tutorials and resources on the web. It is unfortunate that most tutorials exemplify Monads with functional languages, given that most "Monad newbies" are not experienced functional programmers. However, Monads are not specific to Haskell and other pure functional languages and can be used and exemplified in imperative languages as well, which is the goal of this tutorial.</p>
<p><strong>So how is this tutorial different from the rest out there?</strong> This tutorial explains the intuition behind Monads and demonstrates them with a few simple and short python examples. Its goal is to explain Monads simply in less than 15 minutes and thus it refrains from making insightful philosophical and theoretical reflections about <a href="http://blog.plover.com/prog/burritos.html">burritos</a>, <a href="http://web.archive.org/web/20081206204420/http://www.loria.fr/~kow/monads/index.html">space suits</a>, <a href="http://www.infoq.com/presentations/Why-is-a-Monad-Like-a-Writing-Desk">writing desks</a> and endofunctors.</p>
<h1>Motivating Examples</h1>
<p>We will look at 3 example problems for function composition. We will solve each of them in two ways - the standard imperative way and the monad way. Then we'll compare the approaches.</p>
<h2>1. Logging</h2>
<p>Let's assume we have the unary (single argument) functions f1, f2 and f3, each of which returns an increment of its integer parameter. Additionally, each of them generates a readable log message, representing its arithmetic operation:</p>
<pre><code class="python">def f1(x):
    return (x + 1, str(x) + "+1")

def f2(x):
    return (x + 2, str(x) + "+2")

def f3(x):
    return (x + 3, str(x) + "+3")
</code></pre>
<p>Now we would like to chain the functions f1, f2 and f3 given a parameter x - i.e. we want to compute x+1+2+3&#46; Additionally we want to have a readable description of all applied functions.</p>
<p>One way to achieve this is:</p>
<pre><code class="python">log = "Ops:"

res, log1 = f1(x)
log += log1 + ";"

res, log2 = f2(res)
log += log2 + ";"

res, log3 = f3(res)
log += log3 + ";"

print(res, log)
</code></pre>
<p>This solution is far from perfect, as we have repeated "glue code", which accumulates the overall result and prepares the input of the functions. If we add a new function f4 to the sequence, we'll have to repeat the glue code again. Moreover, manipulating the state of the variables <u>res</u> and <u>log</u> makes the code less readable, and is not essential to the program logic.</p>
<p>Ideally, we would like to have something as simple as the chain invocation <u>f3(f2(f1(x)))</u>. Unfortunately, the return types of f1 and f2 are incompatible with the input parameter types of f2 and f3&#46; To solve the problem we introduce two new functions:</p>
<pre><code class="python">def unit(x):
    return (x, "Ops:")

def bind(t, f):
    res = f(t[0])
    return (res[0], t[1] + res[1] + ";")
</code></pre>
<p>Hence, we can solve the problem with a single chained function invocation:</p>
<pre><code class="python">print( bind(bind(bind(unit(x), f1), f2), f3) )
</code></pre>
<p>The following diagram depicts the computational process when <u>x=0</u>. By v1, v2 and v3 we denote the interim values resulting from calling unit and bind:</p>
<p>[caption id="attachment_73" align="aligncenter" width="912"]<img src="{{ site.baseurl }}/assets/example11.png" alt="Example 1 – Computational process of the monadic solution" width="912" height="49" class="size-full wp-image-73" /> Example 1 – Computational process of the monadic solution[/caption]</p>
<p>The <u>unit</u> function converts the input parameter <u>x</u> into a tuple/pair of an integer and a string. The subsequent invocations of <u>bind</u> call their parameter function <u>f</u> and accumulate its result with the interim value represented by the <u>t</u> formal parameter.</p>
<p>This avoids the shortcomings of our previous approach because the <u>bind</u> function implements all the glue code and we don't have to repeat it. We can add a new function f4 by just including it in the sequence as <u>bind(f4, bind(f3, ... ))</u> and we won't have to do other changes.</p>
<h2>2. List of Interim Values</h2>
<p>In this example we assume that we have three simple unary functions:</p>
<pre><code class="python">def f1(x): return x + 1

def f2(x): return x + 2

def f3(x): return x + 3
</code></pre>
<p>As in the previous example we would like to compose them in order to compute x+1+2+3&#46; Additionally we would like to generate a list of all interim and final values - i.e. x, x+1, x+1+2 and x+1+2+3.</p>
<p>Unlike the previous example, in this one the functions are composable as their parameter and result types match. Therefore the simple invocation <u>f3(f2(f1(x)))</u> will give us the desired value of x+1+2+3&#46; However, this won't generate the interim values.</p>
<p>A straightforward approach is:</p>
<pre><code class="python">st = [x]

res = f1(x)
lst.append(res)

res = f2(res)
lst.append(res)

res = f3(res)
lst.append(res);

print(res, lst)
</code></pre>
<p>Again, this is not a very good solution, as we have glue code that takes care of aggregating the interim values in a list. If we add a new function f4 to the sequence, we'll have to repeat the glue code for updating the list.</p>
<p>To overcome these issues, just like in our previous example we introduce two auxiliary functions:</p>
<pre><code class="python">def unit(x):
    return (x, [x])

def bind(t, f):
    res = f(t[0])
    return (res, t[1] + [res])
</code></pre>
<p>Now we can write the entire program as a single sequence of invocations:</p>
<pre><code class="python">print( bind(bind(bind(unit(x), f1), f2), f3) )
</code></pre>
<p>The following diagram depicts the computational process when <u>x=0</u>. Again v1, v2 and v3 are the interim values resulting from calling <u>unit</u> and <u>bind</u>:</p>
<p>[caption id="attachment_72" align="aligncenter" width="919"]<img src="{{ site.baseurl }}/assets/example21.png" alt="Example 2 – Computational process of the monadic solution" width="919" class="size-full wp-image-72" /> Example 2 – Computational process of the monadic solution[/caption]</p>
<h2>3. Nulls/Nones</h2>
<p>Lets try something a bit more interesting with classes and objects. Lets assume we have a class Employee with two methods:</p>
<pre><code class="python">class Employee:
    def get_boss(self):
        # Return the employee's boss

    def get_wage(self):
        # Compute the wage
</code></pre>
<p>Each employee instance has a boss of type <u>Employee</u> and a wage, which can be accessed through the two methods. Both of these methods can return None (i.e. the wage is unknown, or the employee does not have a boss). In this example we want to develop a program, which given an <u>Employee</u> instance <u>john</u> returns his boss's wage. If the wage can no be determined or if <u>john</u> is <u>None</u>, we should return <u>None</u>.</p>
<p>Ideally we would want to write something as simple as:</p>
<pre><code class="python">print(john.get_boss().get_wage())
</code></pre>
<p>However, as the methods can return <u>None</u>, this can result in an error. A simple workaround is:</p>
<pre><code class="python">result = None
if john is not None and john.get_boss() is not None and john.get_boss().get_wage() is not None:
    result = john.get_boss().get_wage()

print(result)
</code></pre>
<p>However, in this solution we are unnecessarily calling multiple times the <u>get_boss</u> and <u>get_wage</u> methods. If they are computationally expensive (e.g. if they access a database) this may be undesirable. Hence our solution should look like:</p>
<pre><code class="python">result = None
if john is not None:
    boss = john.get_boss()
    if boss is not None:
        wage = boss.get_wage()
        if wage is not None:
            result = wage

print(result)
</code></pre>
<p>This obviously is not pretty, since we had to write 3 bloated if statements to get to our result. To solve the problem, we resort to the same trick we used previously. We define the following two functions:</p>
<pre><code class="python">def unit(e):
    return e

def bind(e, f):
    return None if e is None else f(e)
</code></pre>
<p>Now we can write the program in one line:</p>
<pre><code class="python">print( bind(bind(unit(john), Employee.get_boss), Employee.get_wage) )
</code></pre>
<p>You probably noticed that we didn't actually need to call <u>unit(john)</u>, as it simply returns its input parameter. We did it to keep to the previous framework/pattern, so we can define a generalised solution later on. Also, note that in python methods can be used as simple functions. That is, instead of <u>john.get_boss()</u> we can write <u>Employee.get_boss(john)</u>, which allows us to write the code above.</p>
<p>The following diagram illustrates the computational process if <u>john</u> does not have a boss (i.e. <u>john.get_boss()</u> returns <u>None</u>):</p>
<p>[caption id="attachment_71" align="aligncenter" width="1078"]<img src="{{ site.baseurl }}/assets/example31.png" alt="Example 3 – Computational process of the monadic solution" width="1078" class="size-full wp-image-71" /> Example 3 – Computational process of the monadic solution[/caption]</p>
<h1>Generalisation - Monads</h1>
<p>Lets assume we want to compose the functions f1, f2, ... fn. If all input parameters match all return types, we can simply use <u>fn(... f2(f1(x)) ...)</u>. The following diagram depicts the underlying computational process. v1, v2 ... vn represent the interim results of the function invocation.</p>
<p>[caption id="attachment_74" align="aligncenter" width="918"]<img src="{{ site.baseurl }}/assets/dierct_composition1.png" alt="Direct Composition – Computational model" width="918" class="size-full wp-image-74" /> Direct Composition – Computational model[/caption]</p>
<p>However, often this approach is not applicable. For instance in the Logging example the types of the input parameters and the returned values are different. In the 2nd and 3rd examples the functions were composable, but we wanted to "inject" additional logic between the function invocations - in example 2 we wanted to aggregate the interim values and in example 3 we wanted to insert None/Null checks.</p>
<h2>1&#46; Imperative Solution</h2>
<p>In the above examples we first defined a straightforward imperative approach, which is depicted below:</p>
<p>[caption id="attachment_98" align="aligncenter" width="1016"]<img src="{{ site.baseurl }}/assets/imperativecomposition2.png" alt="Imperative Composition - Computational model" width="1016" class="size-full wp-image-98" /> Imperative Composition - Computational model[/caption]</p>
<p>Before calling f1, we execute some initialisation code. For instance, in Example 1 and 2 we initialised variables to store the aggregated log and interim values. After that, we call the functions f1, f2... fn and between the invocations we put some glue code. In Example 1 and 2 the glue code aggregates the log and the interim values. In Example 3, the glue code checks if the interim values are Null/None.</p>
<h2>2&#46; Enter Monads</h2>
<p>As we saw in the examples, this straightforward approach has some unpleasant effects - repeated glue code, multiple Null/None checks etc. In order to achieve more elegant solutions, in the examples above we used a design pattern with two functions (<u>unit</u> and <u>bind</u>). This pattern is called <strong><u>Monad</u></strong>. In essence the <u>bind</u> function implements the glue code and <u>unit</u> implements the initialisation code. This allows us to solve the problem in one line:</p>
<pre><code class="python">bind(bind( ... bind(bind(unit(x), f1), f2) ... fn-1), fn)
</code></pre>
<p>The following diagram displays the computational process:</p>
<p>[caption id="attachment_70" align="aligncenter" width="851"]<img src="{{ site.baseurl }}/assets/monad1.png" alt="Monad - Computational Model" width="851" class="size-full wp-image-70" /> Monad - Computational Model[/caption]</p>
<p>The <u>unit(x)</u> invocation generates an initial value v1&#46; Then <u>bind(v1, f1)</u> generates a new interim value v2, which is then used in the subsequent call to bind - <u>bind(v2, f2)</u>. This continues until the final result is generated. Using this pattern, by using different <u>unit</u> and <u>bind</u> functions we can achieve various types of function compositions. Standard Monad libraries provide predefined sets of ready to use monads (<u>unit</u> and <u>bind</u> functions), which can be used "out of the box" to implement different kinds of composition.</p>
<p>In order to compose the <u>bind</u> and <u>unit</u> functions, the return types of <u>unit</u> and <u>bind</u>, and the type of <u>bind</u>'s first parameter must be compatible. This is called the Monadic Type. In terms of the previous computational diagram, the types of all interim values v1, v2 ... vn must be Monadic.</p>
<p>Lastly, repeating the calls to <u>bind</u> again and again can be tedious and should be avoided. For the purpose we define an auxiliary function:</p>
<pre><code class="python">def pipeline(e, *functions):
    for f in functions:
        e = bind(e, f)
    return e
</code></pre>
<p>Then instead of:</p>
<pre><code class="python">bind(bind(bind(bind(unit(x), f1), f2), f3), f4)
</code></pre>
<p>We can use the shorthand:</p>
<pre><code class="python">pipeline(unit(x), f1, f2, f3, f4)
</code></pre>
<h1>Conclusion</h1>
<p>Monads are a simple and powerful design pattern for function composition. In a declarative language they can be used to implement features of imperative languages like logging and I/O. In an imperative language, they can reduce and isolate the bloated glue code between function invocations. This article only scratches the surface and builds an intuitive understanding of Monads. To learn more you can explore:</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Monad_%28functional_programming%29">Wikipedia</a></li>
<li><a href="http://www.valuedlessons.com/2008/01/monads-in-python-with-nice-syntax.html">Monads in Python</a></li>
<li><a href="http://www.haskell.org/haskellwiki/Monad_tutorials_timeline">List of Monad tutorials</a></li>
</ul>
