---
layout: post
title: Reshaping in Pandas  - Pivot, Pivot-Table, Stack and Unstack explained with
  Pictures
date: 2015-07-01 04:23:43.000000000 +10:00
type: post
published: true
status: publish
categories:
- DataScience
- Miscellaneous
- Python
tags:
- Pandas
- Python
- Reshape
meta:
  _wpas_done_all: '1'
  _wpcom_is_markdown: '1'
  geo_public: '0'
  publicize_google_plus_url: https://plus.google.com/+NikolayGrozev/posts/i5ygqoW5SUg
  _publicize_job_id: '12207630000'
  _wpas_linkedin_publicize_failure: ''
  _publicize_failed_5425643: ''
  _publicize_done_external: a:1:{s:7:"twitter";a:1:{i:5385644;s:59:"https://twitter.com/nikolaygrozev/status/616142002183254016";}}
  _publicize_done_5425648: '1'
  _wpas_done_5385644: '1'
  publicize_twitter_user: nikolaygrozev
  _publicize_done_5425656: '1'
  _wpas_done_5385652: '1'
  _wpas_skip_5385652: '1'
  _wpas_skip_5385644: '1'
  _wpas_skip_5385639: '1'
  _edit_last: '1'
  _kad_blog_head: default
  _kad_post_summery: default
  _kad_post_sidebar: 'yes'
  _kad_sidebar_choice: sidebar-primary
  _kad_blog_author: default
  _kad_blog_carousel_similar: default
  _thumbnail_id: '431'
author:
  login: nikolaygrozev
  email: nikolay.grozev@gmail.com
  display_name: nikolaygrozev
  first_name: ''
  last_name: ''
---
<h1>Introduction</h1>
<p><a href="http://pandas.pydata.org/">Pandas</a> is a popular python library for data analysis. It provides a façade on top of libraries like numpy and matplotlib, which makes it easier to read and transform data. It provides the abstractions of DataFrames and Series, similar to those in R.</p>
<p>In Pandas data reshaping means the transformation of the structure of a table or vector (i.e. DataFrame or Series) to make it suitable for further analysis. Some of Pandas reshaping capabilities do not readily exist in other environments (e.g. SQL or bare bone R) and can be tricky for a beginner.</p>
<p>In this post I'll exemplify some of the most common Pandas reshaping functions and will depict their work with diagrams.</p>
<h1>Pivot</h1>
<p>The <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.pivot.html">pivot</a> function is used to create a new derived table out of a given one. Pivot takes 3 arguements wit the following names: <em><span style="text-decoration:underline;">index,</span></em> <em><span style="text-decoration:underline;">columns</span></em>, and <em><span style="text-decoration:underline;">values</span></em>. As a value for each of these parameters you need to specify a column name in the original table. Then the pivot function will create a new table, whose row and column indices are the unique values of the respective parameters. The cell values of the new table are taken from column given as the <span style="text-decoration:underline;">values</span> parameter.</p>
<p>A bit foggy? Let's give an example. Assume that we are given the following small table:</p>
<p><img src="{{ site.baseurl }}/assets/table.png" alt="Table" width="316" height="220" class="aligncenter size-full wp-image-432" /></p>
<p>Although the semantics doesn't matter in this example, you can think of it as a table of items we want to sell. The <span style="text-decoration:underline;">Item</span> column contains the item names, <span style="text-decoration:underline;">USD</span> is the price in US dollars and <span style="text-decoration:underline;">EU</span> is the price in euros. Each client can be classified as Gold, Silver or Bronze customer and this is specified in the <span style="text-decoration:underline;">CType</span> column.</p>
<p>The following code snippet creates the depicted DataFrame. Note that we will assume these imports are present in all code snippets throughout this article.</p>
<pre><code class="python">from collections import OrderedDict
from pandas import DataFrame
import pandas as pd
import numpy as np

table = OrderedDict((
    ("Item", ['Item0', 'Item0', 'Item1', 'Item1']),
    ('CType',['Gold', 'Bronze', 'Gold', 'Silver']),
    ('USD',  ['1$', '2$', '3$', '4$']),
    ('EU',   ['1€', '2€', '3€', '4€'])
))
d = DataFrame(table)
</code></pre>
<p>In such a table it is not easy to see how the USD price varies over different customer types. We may like to reshape/pivot the table so that all USD prices for an item are on the row to compare more easily. With Pandas we can do so with a single line:</p>
<pre><code class="python">p = d.pivot(index='Item', columns='CType', values='USD')
</code></pre>
<p>This invocation creates a new table/DataFrame whose columns are the unique values in <span style="text-decoration:underline;">d.CType</span> and whose rows are indexed with the unique values of <span style="text-decoration:underline;">d.Item</span>. So far we have defined the indices of the columns and rows, but what about the cells' values? This is defined by the last parameter of the invocation - <span style="text-decoration:underline;">values='USD'</span>. Each cell in the newly created DataFrame will have as a value the entry of the USD column in the original table corresponding to the same Item and CType. The following diagram illustrates this. Column and row indices are marked in red.</p>
<p>[caption id="attachment_436" align="aligncenter" width="640"]<img src="{{ site.baseurl }}/assets/pivoting_simple1.png" alt="Pivoting in action" width="640" class="size-full wp-image-436" /> Pivoting in action[/caption]</p>
<p>In other words, the value of USD for every row in the original table has been transferred to the new table, where its row and column match the Item and CType of its original row. Cells in the new table which do not have a matching entry in the original one are set with NaN.</p>
<p>As an example the following lines perform equivalent queries on the original and pivoted tables:</p>
<pre><code class="python"># Original DataFrame: Access the USD cost of Item0 for Gold customers
print (d[(d.Item=='Item0') &amp; (d.CType=='Gold')].USD.values)

# Pivoted DataFrame: Access the USD cost of Item0 for Gold customers
print (p[p.index=='Item0'].Gold.values)
</code></pre>
<p><span style="text-decoration:underline;"><strong>Note</strong></span> that in this example the pivoted table does not contain any information about the EU column! Indeed we can't see those euro symbols anywhere! Thus the pivoted table is a simplified version of the original data and only contains information about the columns we specified as parameters to the pivot method.</p>
<h1>Pivoting By Multiple Columns</h1>
<p>Now what if we want to extend the previous example to have the EU cost for each item on its row as well? This is actually easy - we just have to omit the <span style="text-decoration:underline;">values</span> parameter as follows:</p>
<pre><code class="python">p = d.pivot(index='Item', columns='CType')
</code></pre>
<p>In this case Pandas will create a hierarchical column index (<a href="http://pandas.pydata.org/pandas-docs/stable/advanced.html">MultiIndex</a>) for the new table. You can think of a hierarchical index as a set of trees of indices. Each indexed column/row is identified by a unique sequence of values defining the "path" from the topmost index to the bottom index. The first level of the column index defines all columns that we have not specified in the pivot invocation - in this case USD and EU. The second level of the index defines the unique value of the corresponding column. The following diagram depicts this:</p>
<p>[caption id="attachment_428" align="aligncenter" width="943"]<img src="{{ site.baseurl }}/assets/pivoting_simple_multicolumn.png" alt="Multi-column pivoting" width="943" height="395" class="size-full wp-image-428" /> Multi-column pivoting[/caption]</p>
<p>We can use this hierarchical column index to filter the values of a single column from the original table. For example <span style="text-decoration:underline;">p.USD</span> returns a pivoted DataFrame with the USD values only and it is equivalent to the pivoted DataFrame from the previous section.</p>
<p>To exemplify hierarchical indices, the expression <span style="text-decoration:underline;">p.USD.Bronze</span> selects the first column in the pivoted table.</p>
<p>As a further example the following queries on the original and pivoted tables are equivalent:</p>
<pre><code class="python"># Original DataFrame: Access the USD cost of Item0 for Gold customers
print(d[(d.Item=='Item0') &amp; (d.CType=='Gold')].USD.values)

# Pivoted DataFrame: p.USD gives a "sub-DataFrame" with the USD values only
print(p.USD[p.USD.index=='Item0'].Gold.values)
</code></pre>
<h1>Common Mistake in Pivoting</h1>
<p>As we saw the <span style="text-decoration:underline;">pivot</span> method takes at least 2 column names as parameters - the <span style="text-decoration:underline;">index</span> and the <span style="text-decoration:underline;">columns</span> named parameters. What will happen if we have multiple rows with the same values for these columns? How will the pivot method determine the value of the corresponding cell in the pivoted table? The following diagram depicts the problem:</p>
<p>[caption id="attachment_427" align="aligncenter" width="758"]<img src="{{ site.baseurl }}/assets/pivoting_simple_error.png" alt="Common error in pivoting" width="758" height="261" class="size-full wp-image-427" /> Common error in pivoting[/caption]</p>
<p>In this example we have two rows with the same values ("<em>Item0"</em> and "<em>Gold")</em> for the <span style="text-decoration:underline;">Item</span> and <span style="text-decoration:underline;">CType</span> columns. The pivot method can not know what should be the value of the corresponding value in the pivoted table. Thus it throws an exception with the following message:</p>
<pre><code>ValueError: Index contains duplicate entries, cannot reshape
</code></pre>
<p>The following code reproduces the issue:</p>
<pre><code class="python">table = OrderedDict((
    ("Item", ['Item0', 'Item0', 'Item0', 'Item1']),
    ('CType',['Gold', 'Bronze', 'Gold', 'Silver']),
    ('USD',  ['1/pre&gt;, '2/pre&gt;, '3/pre&gt;, '4/pre&gt;]),
    ('EU',   ['1€', '2€', '3€', '4€'])
))
d = DataFrame(table)
p = d.pivot(index='Item', columns='CType', values='USD')
</code></pre>
<p>Hence, before calling <em><span style="text-decoration:underline;">pivot</span></em> we need to ensure that our data does not have rows with duplicate values for the specified columns. If we can't ensure this we may have to use the <span style="text-decoration:underline;">pivot_table</span> method instead.</p>
<h1>Pivot Table</h1>
<p>The <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.pivot_table.html">pivot_table</a> method comes to solve this problem. It works like pivot, but it aggregates the values from rows with duplicate entries for the specified columns. In other words, in the previous example we could have used the mean, the median or another aggregation function to compute a single value from the conflicting entries. This is depicted in the example below.</p>
<p>[caption id="attachment_441" align="aligncenter" width="749"]<img src="{{ site.baseurl }}/assets/pivoting_table_simple1.png" alt="Pivoting by a single column" width="749" height="255" class="size-full wp-image-441" /> The pivot_table method[/caption]</p>
<p>Note that in this example we removed the $ and € symbols to simplify things. There are two rows in the original table, whose values for <span style="text-decoration:underline;">Item</span> and <span style="text-decoration:underline;">CType</span> are duplicate. The corresponding value in the pivot table is defined as the mean of these two original values. The pivot_table method takes a parameter called <span style="text-decoration:underline;">aggfunc</span>, which is the aggregation function used to combine the multitude of values. In this example we used the mean function from numpy. The following snippet lists the code to reproduce the example:</p>
<pre><code class="python">table = OrderedDict((
    ("Item", ['Item0', 'Item0', 'Item0', 'Item1']),
    ('CType',['Gold', 'Bronze', 'Gold', 'Silver']),
    ('USD',  [1, 2, 3, 4]),
    ('EU',   [1.1, 2.2, 3.3, 4.4])
))
d = DataFrame(table)
p = d.pivot_table(index='Item', columns='CType', values='USD', aggfunc=np.min)
</code></pre>
<p>In essence <em><span style="text-decoration:underline;">pivot_table</span></em> is a generalisation of <em><span style="text-decoration:underline;">pivot</span></em>, which allows you to aggregate multiple values with the same destination in the pivoted table.</p>
<h1>Stack/Unstack</h1>
<p>In fact pivoting a table is a special case of stacking a DataFrame. Let us assume we have a DataFrame with MultiIndices on the rows and columns. Stacking a DataFrame means moving (also rotating or pivoting) the innermost column index to become the innermost row index. The inverse operation is called unstacking. It means moving the innermost row index to become the innermost column index. The following diagram depicts the operations:</p>
<p>[caption id="attachment_443" align="aligncenter" width="827"]<img src="{{ site.baseurl }}/assets/stack-unstack1.png" alt="Stack and Unstack" width="827" height="535" class="size-full wp-image-443" /> Stack and Unstack[/caption]</p>
<p>In this example we look at a DataFrame with 2-level hierarchical indices on both axes. Stacking takes the most-inner column index (i.e. c00, c01, c10), makes it the most inner row index and reshuffles the cell values accordingly. Inversely, unstacking moves the inner row indices (i.e. r00, r01) to the columns.</p>
<p>Typically stacking makes the DataFrame taller, as it is "stacking" data in fewer columns and more rows. Similarly, unstacking usually makes it shorter and wider or broader. The following reproduces the example:</p>
<pre><code class="python"># Row Multi-Index
row_idx_arr = list(zip(['r0', 'r0'], ['r-00', 'r-01']))
row_idx = pd.MultiIndex.from_tuples(row_idx_arr)

# Column Multi-Index
col_idx_arr = list(zip(['c0', 'c0', 'c1'], ['c-00', 'c-01', 'c-10']))
col_idx = pd.MultiIndex.from_tuples(col_idx_arr)

# Create the DataFrame
d = DataFrame(np.arange(6).reshape(2,3), index=row_idx, columns=col_idx)
d = d.applymap(lambda x: (x // 3, x % 3))

# Stack/Unstack
s = d.stack()
u = d.unstack()
</code></pre>
<p>In fact Pandas allows us to stack/unstack on [any level of the indices](http://In fact Pandas allows us to stack/unstack on any level of the index) so our previous explanation was a bit simplified :). Thus, in the previous example we could have stacked on the outermost index level as well! However the default (and most typical case) is to stack/unstack on the innermost index level.</p>
<p>Stacking and unstacking can also be applied to data with flat (i.e. non-hierchical) indices. In this case one of the indices is de facto removed (the columns index if stacking, and the rows if unstacking) and its values are nested in the other index, which is now a MultiIndex. Therefore the result is always a Series with a hierarchical index. The following example demonstrates this:</p>
<p>[caption id="attachment_447" align="aligncenter" width="672"]<img src="{{ site.baseurl }}/assets/stack-simple2.png" alt="Stack and Unstack" width="672" height="402" class="size-full wp-image-447" /> Stack and Unstack[/caption]</p>
<p>In this example we take a DataFrame similar to the one from the beginning. Instead of pivoting, this time we stack it, and we get a Series with a MultiIndex composed of the initial index as first level, and the table columns as a second. Unstacking can help us get back to our original data structure.</p>
