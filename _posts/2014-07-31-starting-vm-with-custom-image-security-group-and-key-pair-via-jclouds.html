---
layout: post
title: Starting VM with custom image, security group and key-pair via JClouds
date: 2014-07-31 02:25:32.000000000 +10:00
type: post
published: true
status: publish
categories:
- Miscellaneous
tags:
- aws
- java
- jclouds
- virtual machine
- VM
- VM Image
meta:
  _wpas_done_all: '1'
  _wpcom_is_markdown: '1'
  geo_public: '0'
  _publicize_pending: '1'
  publicize_google_plus_url: https://plus.google.com/116873873608085229608/posts/FueAkNe8HMb
  _wpas_done_5385652: '1'
  _publicize_done_external: a:1:{s:11:"google_plus";a:1:{s:21:"116873873608085229608";b:1;}}
  publicize_twitter_user: nikolaygrozev
  publicize_twitter_url: http://t.co/0IkijBbvrM
  _wpas_done_5385644: '1'
  publicize_linkedin_url: ''
  _wpas_done_5385639: '1'
  _wpas_skip_5385652: '1'
  _wpas_skip_5385644: '1'
  _wpas_skip_5385639: '1'
  _edit_last: '1'
  _kad_blog_head: default
  _kad_post_summery: default
  _kad_post_sidebar: 'yes'
  _kad_sidebar_choice: sidebar-primary
  _kad_blog_author: default
  _kad_blog_carousel_similar: default
author:
  login: nikolaygrozev
  email: nikolay.grozev@gmail.com
  display_name: nikolaygrozev
  first_name: ''
  last_name: ''
---
<h1>Introduction</h1>
<p>Recently I needed to programatically start EC2 instances from a private <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AMIs.html">AMI</a> (VM Image) as a part of a new provisioning algorithm I was working on. I also wanted to specify my predefined security group and key-pair, so that the new VM is usable right away. Lastly, I wanted to implement it as EC2-independent as possible, so that I can include multiple clouds later on.</p>
<p>There are a few Multi-Cloud libraries out there, whose purpose is to provide just that - a cloud provider agnostic API for managing cloud resources. After struggling a bit with both <a href="https://libcloud.apache.org/">Apache LibCloud</a> and <a href="https://jclouds.apache.org/">Apache JClouds</a> I could finally implement this in JClouds.</p>
<h1>JClouds Implementation</h1>
<p>The easiest way to set up JClouds is by using it as a <a href="https://jclouds.apache.org/start/install/">Maven dependency</a>. The following method implements the provisioning:</p>
<pre><code class="java">public static List&lt;List&lt;String&gt;&gt; launchInstances(
        String providerId,
        String userName,
        String password,
        String locationId,
        String imageId,
        String hardwareId,
        String securityGroupName,
        String keyPairName,
        String groupName,
        int numVMs,
        Properties imageOwnerIdFilter) {

    // Get the Compute abstraction for the provider.
    // Override the available VM images
    ComputeService compute = ContextBuilder.
            newBuilder(providerId).
            credentials(userName, password).
            overrides(imageOwnerIdFilter).
            buildView(ComputeServiceContext.class).getComputeService();

    // Create a template for the VM
    Template template = compute.
            templateBuilder().
            locationId(locationId).
            imageId(imageId).
            hardwareId(hardwareId).build();

    // Specify your own security group
    TemplateOptions options = template.getOptions();
    options.securityGroups(securityGroupName);

    // Specify your own keypair if the current provider allows for this
    try {
        Method keyPairMethod = options.getClass().getMethod("keyPair", String.class);
        keyPairMethod.invoke(options, keyPairName);
    } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException
            | InvocationTargetException e) {
        throw new IllegalStateException("Provider: " + providerId + " does not support specifying key-pairs.", e);
    }

    final List&lt;List&lt;String&gt;&gt; launchedNodesAddresses = new ArrayList&lt;&gt;();
    try {
        // Launch the instances...
        Set&lt;? extends NodeMetadata&gt; launchedNodesMetadata = compute.createNodesInGroup(groupName, numVMs, template);

        // Collect the addresses ...
        for (NodeMetadata nodeMetadata : launchedNodesMetadata) {
            launchedNodesAddresses.add(new ArrayList&lt;&gt;(nodeMetadata.getPublicAddresses()));
        }
    } catch (RunNodesException e) {
        throw new IllegalStateException("Nodes could not be created.", e);
    }

    return launchedNodesAddresses;
}
</code></pre>
<p>The input parameters of the method are:</p>
<ul>
<li><u>providerId</u> - a JClouds specific ID of the provider (AWS, RightScale etc.);</li>
<li><u>userName</u> - the user name for the provider;</li>
<li><u>password</u> - the password or secret key;</li>
<li><u>locationId</u> - a JClouds specific ID of the location of the cloud data centre site;</li>
<li><u>imageId</u> - the ID of the VM Image or AMI in AWS;</li>
<li><u>hardwareId</u> - the type of the VM (e.g. m1.small);</li>
<li><u>securityGroupName</u> - the name of the predefined security group;</li>
<li><u>keyPairName</u> - the name of the predefined key-pair;</li>
<li><u>groupName</u> - a name pattern for the newly created VMs. <u>Must be lower case</u>;</li>
<li><u>numVMs</u> - how many VMs you want to create at once. If 1 - a single VM is created;</li>
<li><u>imageOwnerIdFilter</u> - by default some providers do not list private VM images. Thus you need to specify a custom filter/query that will make them list your private images.</li>
</ul>
<p>In the next section we'll see how all these parameters can be specified.</p>
<p>The above code is pretty self-evident and follows the standard JClouds templates. The first interesting point is that we need to override the list of available VM images (line 19) with a custom query, so that we can use our own private VM image. Secondly JClouds does not support specifying key-pairs for all cloud providers and hence the "keyPair" method is not present in any base class. To avoid using provider specific <u>ComputeService</u> implementations we dynamically inspect if the current provider supports key-pairs (lines 35-36).</p>
<p>As a result the method returns a list of the addresses for each instantiated VM.</p>
<h1>Running in AWS</h1>
<p>The above method is generic and is not bound to AWS EC2&#46; In order to run it on EC2 we need to specify the appropriate parameters as in the following code sample:</p>
<pre><code class="java">String providerId = "aws-ec2";
String accesskeyid = "...";
String secretkey = "...";
String imageOwnerId = "...";
String locationId = "ap-southeast-2a";
String imageId = "ap-southeast-2/ami-XXX";
String hardwareId = org.jclouds.ec2.domain.InstanceType.T1_MICRO;
String securityGroupName = "SecGroupName";
String keyPairName = "KeyPairName";
String groupName = "groupname"; // Must be lower case
int numVMs = 1;

Properties imageOwnerIdFilter = new Properties();
imageOwnerIdFilter.setProperty(
    "jclouds.ec2.ami-query", "owner-id=" +
    imageOwnerId +
    ";state=available;image-type=machine");

List&lt;List&lt;String&gt;&gt; launchedNodesAddresses = launchInstances(providerId,
    accesskeyid,
    secretkey,
    locationId,
    imageId,
    hardwareId,
    securityGroupName,
    keyPairName,
    groupName,
    numVMs,
    imageOwnerIdFilter);

System.out.println(launchedNodesAddresses);
</code></pre>
<p>Note that in the above code we use the AWS region as a part of the image ID (line 6). This is a requirement for EC2&#46; Also we constructed an AWS specific image query with the image owner id as a parameter (line 14).</p>
