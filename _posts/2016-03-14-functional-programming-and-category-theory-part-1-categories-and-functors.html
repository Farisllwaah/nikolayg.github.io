---
layout: post
title: Functional Programming and Category Theory [Part 1] - Categories and Functors
date: 2016-03-14 17:18:19.000000000 +11:00
type: post
published: true
status: publish
categories:
- Category Theory
- Functional programming
- Scala
tags:
- Category Theory
- Functional programming
- Scala
meta:
  _wpas_done_all: '1'
  _wpcom_is_markdown: '1'
  geo_public: '0'
  _publicize_job_id: '20734887053'
  _thumbnail_id: '622'
  _edit_last: '1'
  _kad_blog_head: default
  _kad_post_summery: default
  _kad_post_sidebar: 'yes'
  _kad_sidebar_choice: sidebar-primary
  _kad_blog_author: default
  _kad_blog_carousel_similar: default
author:
  login: nikolaygrozev
  email: nikolay.grozev@gmail.com
  display_name: nikolaygrozev
  first_name: ''
  last_name: ''
---
<h1>Table of Contents</h1>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#categories">Categories</a>
<ul>
<li><a href="#categories-examples">Examples</a></li>
<li><a href="#categories-hask">The Hask Category</a></li>
</ul>
</li>
<li><a href="#functors">Functors</a>
<ul>
<li><a href="#functors-in-fp">Functors in FP</a></li>
<li><a href="#functors-in-code">Functors in code</a></li>
<li><a href="#functors-examples">Examples</a></li>
</ul>
</li>
</ul>
<p><!-- ---------------------------------------------------------------------- --></p>
<div id="introduction">
<h1>Introduction</h1>
<p>Category Theory is a mathematical discipline with a wide range of applications in theoretical computer science. Concepts like <em>Category</em>, <em>Functor</em>, <em>Monad</em>, and others, which were originally defined in Category Theory, have become pivotal for the understanding of modern Functional Programming (FP) languages and paradigms. The meaning and applications of these terms in FP can be understood without in-depth knowledge of the corresponding mathematical definitions and axiomatic. However, a common knowledge of the underlying theory can help FP programmers understand the design and structure of commonly used libraries and tools and be more productive.</p>
<p>This series of tutorials defines and illustrates the Category Theory concepts which are most widely adopted in FP. We will use simple Scala and pseudocode examples to illustrate the new terms.</p>
<p><!-- ---------------------------------------------------------------------- --></p>
<div id="categories">
<h1>Categories</h1>
<p>A <strong>category</strong> is a simple algebraic structure for modelling objects and their relationships. A category <u><strong>C</strong></u> consists of a collection of objects <u><strong>ob(C)</strong></u> and a collection of arrows/morphisms <u><strong>hom(C)</strong></u> connecting the objects. In other words, every arrow <u><strong>f</strong></u> can be defined as a pair <u><strong>[a,b]</strong></u> of the objects it connects. We write <u><strong>f: a &rarr; b</strong></u>.</p>
<p>A category also defines an operation for composing arrows, such that for every <u><strong>f: a &rarr; b</strong></u> and <u><strong>g : b &rarr; c</strong></u>, their composition <u><strong>g &#8728; f</strong></u> is also an arrow, which connects <u><strong>a</strong></u> and <u><strong>c</strong></u> - i.e. <u><strong>g &#8728; f: a &rarr; c</strong></u>.</p>
<p>A collection of objects and arrows qualifies as a category only if:</p>
<ul>
<li>The composition is associative. More formally, <u><strong>h &#8728; (g &#8728; f) = (h &#8728; g) &#8728; f</strong></u> for every three arrows, and;</li>
<li>For every object <u><strong>a</strong></u> there is an identity arrow (i.e. a loop) <u><strong>i<sub>a</sub></strong></u> that connects it to itself: <u><strong>i<sub>a</sub>: a &rarr; a</strong></u>. </li>
<li>The identities should have the obvious property that for every <u><strong>f: a &rarr; b</strong></u> the following is true <u><strong>i<sub>b</sub> &#8728; f = f = f &#8728; i<sub>a</sub></strong></u>. In other words, identities are <em>neutral</em> to composition.</li>
</ul>
<p>[caption id="attachment_605" align="aligncenter" width="320"]<a href="http://www.nikgrozev.org/wp-content/uploads/2016/03/category.jpg" rel="attachment wp-att-605"><img class="wp-image-605 size-medium" src="{{ site.baseurl }}/assets/category.jpg?w=320" alt="Category" /></a> A category of 4 objects. For every object there must be an identity arrow (i.e. loop). The order of composition should not matter.[/caption]</p>
<div id="categories-examples">
<h2>Examples</h2>
<p>An intuitive example of a category is the inter-city road infrastructure. A portion of this category is depicted in the diagram below. In it, the objects are all cities around the world. We consider two cities to be connected with an arrow if one is reachable from the other. We assume each city is reachable from itself which is represented with the identity arrows. If we can travel from city <u><strong>A</strong></u> to <u><strong>B</strong></u>, and from <u><strong>B</strong></u> to <u><strong>C</strong></u>, then we can do so from <u><strong>A</strong></u> to <u><strong>C</strong></u>. Hence, we can compose arrows.</p>
<p>[caption id="attachment_611" align="aligncenter" width="360"]<a href="http://www.nikgrozev.org/wp-content/uploads/2016/03/category_roads.jpg?w=360" rel="attachment wp-att-611"><img class="wp-image-611 size-medium" src="{{ site.baseurl }}/assets/category_roads.jpg" alt="Category_Roads" /></a>The road network forms a category.[/caption]</p>
<p>More generally, every directed graph forms a category whose objects are the graph nodes. In it, two nodes/objects <u><strong>a</strong></u> and <u><strong>b</strong></u> are connected with an arrow only if there is <em>path</em> between them in the graph. We also consider that every node in the graph has an arrow to itself - i.e. it is reachable from itself.</p>
<p>In Object Oriented Programming (OOP), a class hierarchy also forms a category. The category objecta are the types (e.g. classes, traits, interfaces). We consider two types <u><strong>A</strong></u> and <u><strong>B</strong></u> to be connected with an arrow if <u><strong>A</strong></u> is a subtype of <u><strong>B</strong></u>. These arrows are composable, because if <u><strong>A</strong></u> is a subtype of <u><strong>B</strong></u>, and <u><strong>B</strong></u> of <u><strong>C</strong></u>, then <u><strong>A</strong></u> is a subtype of <u><strong>C</strong></u>. Finally, each type is a subtype of itself and thus we have identity arrows as well. This is depicted in the following figure.</p>
<p>[caption id="attachment_615" align="aligncenter" width="460"]<a href="http://www.nikgrozev.org/wp-content/uploads/2016/03/category_oop.jpg" rel="attachment wp-att-615"><img src="{{ site.baseurl }}/assets/category_oop.jpg?w=460" alt="Category of Programming types." class="size-medium wp-image-615" /></a> Category of types.[/caption]</p>
<div id="categories-hask">
<h2>The Hask Category</h2>
<p>In Functional Programming, the <u><strong>Hask</strong></u> category has a special role. The objects of <u><strong>Hask</strong></u> are all types of the Haskel programming language - i.e. <u><strong>Ob(Hask) = {Int, String, ...}</strong></u>. We can generalise that to the types of other languages, like Scala, as well. For every function converting one type to another, in <u><strong>Hask</strong></u> there is an arrow between the two types. Arrow composition is just function composition. The identity arrows correspond to the identity functions. The following diagram depicts a portion of the <u><strong>Hask</strong></u> category.</p>
<p>[caption id="attachment_617" align="aligncenter" width="360"]<a href="http://www.nikgrozev.org/wp-content/uploads/2016/03/hask.jpg" rel="attachment wp-att-617"><img src="{{ site.baseurl }}/assets/hask.jpg?w=360" alt="The Hask Category" class="size-medium wp-image-617" /></a> The Hask Category[/caption]</p>
<p><!-- ---------------------------------------------------------------------- --></p>
<div id="functors">
<h1>Functors</h1>
<p>In category theory, a Functor <u><strong>F</strong></u> is a transformation between two categories <u><strong>A</strong></u> and <u><strong>B</strong></u>. We write <u><strong>F : A &rarr; B</strong></u>. <u><strong>F</strong></u> must map every object and arrow from <u><strong>A</strong></u> to <u><strong>B</strong></u>. In other words, if <u><strong>a &isin; ob(A)</strong></u> then <u><strong>F(a) &isin; ob(B)</strong></u>, and if <u><strong>f &isin; Hom(A)</strong></u> then <u><strong>F(f) &isin; Hom(B)</strong></u>.</p>
<p>We also require that <u><strong>F</strong></u> preserves the structure (i.e. identity arrows and composition) of the source category. More formally:</p>
<ul>
<li>If <u><strong>f : a &rarr; b</strong></u> is an arrow in <u><strong>A</strong></u> then <u><strong>F(f):F(a) &rarr; F(B)</strong></u> is an arrow in <u><strong>B</strong></u>.</li>
<li><u><strong>F(id<sub>X</sub>) = id<sub>(F(X))</sub></strong></u>, which means that each identity arrow in <u><strong>A</strong></u> is transformed to an identity arrow of the corresponding object in <u><strong>B</strong></u>.</li>
<li><u><strong>F(g &#8728; f) = F(g) &#8728; F(f)</strong></u>, which means that the mapping of arrows' composition in <u><strong>A</strong></u> is a composition of their mappings in <u><strong>B</strong></u>.</li>
</ul>
<p>[caption id="attachment_619" align="aligncenter" width="940"]<a href="http://www.nikgrozev.org/wp-content/uploads/2016/03/functor.jpg" rel="attachment wp-att-619"><img src="{{ site.baseurl }}/assets/functor.jpg?w=940" alt="A Functor" class="size-large wp-image-619" /></a> A Functor from A to B.[/caption]</p>
<p>When a functor <u><strong>F</strong></u> transforms a category <u><strong>A</strong></u> into itself, we call it an <em>endofunctor</em> and we write <u><strong>F:A &rarr; A</strong></u>.</p>
<p>[caption id="attachment_622" align="aligncenter" width="940"]<a href="http://www.nikgrozev.org/wp-content/uploads/2016/03/endofunctor.jpeg" rel="attachment wp-att-622"><img src="{{ site.baseurl }}/assets/endofunctor.jpeg?w=940" alt="An Endo Functor" class="size-large wp-image-622" /></a> An Endofunctor[/caption]</p>
<div id="functors-in-fp">
<h2>Functors in FP</h2>
<p>Before we delve into Functors and FP, we need to introduce the concept of a <u><em>type constructor</em></u>. Essentially, a type constructor is a generic type definition, which takes another type as a parameter. For example, in Scala <u><strong>List[T]</strong></u>, <u><strong>Vector[T]</strong></u>, and <u><strong>Option[T]</strong></u> are type constructor. You need to specify the value of the type parameter <u><strong>T</strong></u> in order to produce a concrete type. For example, <strong>List[String]</strong> is a type, while <strong>List</strong> itself is not - it is a type constructor. We will write <strong>TC[ _ ]</strong> to denote that <u><strong>TC</strong></u> is a type constructor.</p>
<p>Functors in Category Theory are a much more general concept than in functional programming (FP). <u>All functors in FP are just endofunctors in <strong>Hask</strong></u>. Furthermore, each functor <u><strong>F</strong></u> is associated with a type constructor <strong>TC[ _ ]</strong>. Each type <u><strong>A</strong></u> in <u><strong>Hask</strong></u> is transformed to <u><strong>TC[A]</strong></u>. For example, if <u><strong>TC = List</strong></u> then <u><strong>F: Int &rarr; List[Int]</strong></u>. In other words, the type constructor uniquely defines the mapping of <u><strong>Hask</strong></u> objects.</p>
<p>In order to define a functor, we also need to define the arrow mapping. The arrows in <u><strong>Hask</strong></u> are just functions. Hence, we need to provide a function called <u><strong>map</strong></u> with the following signature: <u><strong>map: (A &rarr; B) &rarr; (TC[A] &rarr; TC[B])</strong></u>. For every arrow/function <u><strong>f: A &rarr; B</strong></u> it returns its projection/mapping which is also a function - <u><strong>F(f): TC[A] &rarr; TC[B]</strong></u>.</p>
<p>To summarise, a functor in FP is uniquely defined by a type constructor <strong>TC[ _ ]</strong> and a map function with the aforementioned signature. The following diagram depicts a functor, whose type constructor is <strong>List[_]</strong>.</p>
<p>[caption id="attachment_626" align="aligncenter" width="840"]<a href="http://www.nikgrozev.org/wp-content/uploads/2016/03/haskfunctor1.jpg" rel="attachment wp-att-626"><img src="{{ site.baseurl }}/assets/haskfunctor1.jpg?w=840" alt=" A Hash Functor" class="size-large wp-image-626" /></a> The List functor.[/caption]</p>
<div id="functors-in-code">
<h2>Functors in code</h2>
<p>Following the previous definitions, in Scala a functor can be defined as:</p>
<pre><code class="scala">trait Functor[TC[_]] {
    def map[A,B] (f: A =&gt; B): (TC[A] =&gt; TC[B])
}
</code></pre>
<p>Note that the return type of <u><strong>map</strong></u> is a function. Often the caller just wants to apply/run this function to a given arguement, instead of passing it on as an arguement or reusing it later on. Thus, it is convenient to use another analogous definition of a functor, which also applies the resulting function:</p>
<pre><code class="scala">trait Functor[TC[_]] {
    def map[A,B] (f: A =&gt; B)(param : TC[A]) : TC[B]
}
</code></pre>
<p>This is essentially a <em>shortcut</em> for mapping a function and applying it in one go. We can also define the <u><strong>map</strong></u> function as a method of the type constructor <strong>TC</strong> itself:</p>
<pre><code class="scala">trait TC[A] {
    def map[B] (f: A =&gt; B): TC[B]
}
</code></pre>
<p>For simplicity, in this case we can just say that <strong>TC</strong> itself is a functor, because it is a <em>type constructor</em> and has a <em>map</em> function. To make it more readable we can just write:</p>
<pre><code class="scala">trait Functor[A] {
    def map[B] (f: A =&gt; B): Functor[B]
}
</code></pre>
<p>This trait can then be implemented from all concrete type constructors (e.g. <strong>List</strong> and <strong>Vector</strong>) thus making them functors.</p>
<div id="functors-examples">
<h2>Examples</h2>
<p>In FP, functors are usually applied to map/convert instances of generic data structures (i.e. type constructors) in a way which preserves their inner structure. For collections like <strong>List</strong> and <strong>Vector</strong> we would implement the <em>map</em> function by just applying it to every element, as in the following pseudocode:</p>
<pre><code class="scala">class List[A] extends Functor[A] {
    // ... 
    def map[B] (f: A =&gt; B): List[B] = {
        this match {
            case List() =&gt; this
            case h::t =&gt; f(h)::(t.map(f))
        }
    }
    // ... 
}
</code></pre>
<p>For type constructors which encode <em>"success-or-failure"</em> state like <strong>Option</strong> or <strong>Either</strong> the map function can be applied only if there is a contained value:</p>
<pre><code class="scala">class Option[A] extends Functor[A] {
    // ... 
    def map[B] (f: A =&gt; B): Option[B] = {
        this match {
            case None =&gt; None
            case Some(x) =&gt; Some(f(x))
        }
    }
    // ... 
}
</code></pre>
<p>Given that all these functors have a common supertype allows us to write functions which will work with all of them. For example:</p>
<pre><code class="scala">def useAnyIntFunctor(functor: Functor[Int]) =
     functor.map(_ + 5).map(_ * 2) 
</code></pre>
<p>This will work <em>"as expected"</em> with all functors - Option, List, etc. However, in this example the return type is <strong>Functor</strong>, not the actual compile-time type of the parameter. This can be amended by defining a method type parameter for the arguement's type.</p>
<p><u><strong>Update</strong></u>: updated with comments from <a href="https://twitter.com/kenscambler">Ken Scambler</a> and other collegues from <a href="http://www.rea-group.com/IRM/content/default.aspx">REA</a></div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
